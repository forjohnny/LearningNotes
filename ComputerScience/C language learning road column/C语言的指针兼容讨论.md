# C语言的指针兼容性讨论

</center>

<img src="image\大米的营养构成.jpg" width="700">

*图片来源-[百度图片](https://image.baidu.com/search/detail?ct=503316480&z=0&ipn=d&word=%E5%A4%A7%E7%B1%B3%E7%9A%84%E8%90%A5%E5%85%BB%E6%9E%84%E6%88%90&step_word=&hs=0&pn=1&spn=0&di=11319777150&pi=0&rn=1&tn=baiduimagedetail&is=0%2C0&istype=2&ie=utf-8&oe=utf-8&in=&cl=2&lm=-1&st=-1&cs=572999657%2C4140609138&os=3979122895%2C3451462115&simid=3323785265%2C377976174&adpicid=0&lpn=0&ln=1965&fr=&fmq=1497802468015_R&fm=result&ic=0&s=undefined&se=&sme=&tab=0&width=&height=&face=undefined&ist=&jit=&cg=&bdtype=0&oriquery=&objurl=http%3A%2F%2Fimages.qschou.com%2Ffiles%2Fqschou.com%2Feditor%2F201605%2F13%2F1463138049727e32815cbfd2a796f.jpg&fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z%26e3Bqfvi57_z%26e3Bv54AzdH3Fr653jvpAzdH3Fu991cubl-mnn0-9j00-lak1-cdmw8lnb1ujc&gsm=0&rpstart=0&rpnum=0)*

*这里首先给大家科普一个小知识，如上图，我们平时吃的米饭通常是精白米，其实就是稻谷的胚乳，营养价值只占稻谷的5%。而糙米和留胚米的营养价值占稻谷的85%。因此我们吃的精米饭其实营养价值很少，不妨可以去某东或某猫买点糙米或胚芽米，尝尝高营养价值的糙米或胚芽米！*

</center>

## 引言

昨天有一位网友在我的博客《[C语言的const类型限定符](http://blog.csdn.net/libing403/article/details/72944406)》留言了一个问题，涉及到const限定符合指针兼容性的问题，一开始我也一头雾水，摸不着头脑，后来经过查阅资料弄清楚了，主要是指针兼容性问题。这里就总结一下指针兼容性的知识。

## const限定及两级解引用问题

这里首先讨论一下那一位网友的问题。

问题：

博主能说明一下第一个例子为什么不合法，第二个例子为什么合法吗？困惑了好久，还请博主能指点迷津。
例子1

```c
char **p1;
const char **p2=p1;//不合法 [Warning] initialization from
incompatible pointer type [enabled by default]
```

例子2

```c
char *p1;
const char *p2=p1;//合法
```

我答：

首先，你第一个例子编译出现警告，但程序还是编译通过了，程序可以运行。

其次，出现警告，其原因我分析如下：

首先理解下面这段话的关键点：

指针之间的赋值比数值之间的赋值要严格。把const指针赋值给非const指针是不安全的，因为这样可以使新的指针改变const指针指向的数据。编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。但是把非const指针赋值给const指针没问题，**前提是只进行一次解引用。但是进行两级解引用时，这样的赋值也是不安全的。**

你给出的例子2，把非const指针赋值给const指针并且只进行一次解引用，这样没问题，因此是合法的。但是你的例子1，进行两次解引用，因此是不合法的，编译器会给出警告，即指针的兼容性问题。

那么如何理解例子1存在不安全问题呢？看下面的例子：

```c
const int **pp2;
int *p1;
const int n=13;
pp2=&p1; /*允许,但是这导致const限定符失效（根据第一行代码，不能通过*pp2修改它指向的内容）*/
*pp2= &n; /*有效，两者都声明为const，但是这导致p1指向n（*pp2已被修改）*/
*p1=10;   /*有效，但是这将改变n的值（但是根据第3行代码，要求不能改变n的值）*/
```

为什么会这样？C标准规定了通过非const指针更改const数据是未定义的。不同的编译器编译的程序其运行结果可能是不一样的。我在windows下使用gcc编译，程序运行后n的最终值是10。

当然，可以忽略这些警告，但是程序运行的结果是不可信的。

这样，你两个例子的疑惑就算解决了。

## 类型转换问题

指针间的赋值比数值类型之间的赋值更加严格，例如，不用类型转换就可以把int类型的值赋给double类型的变量，但是两个类型的指针不允许这样做。

```c
int n=5;
double x;
int * p1=&n;
double *pd=&x;
x=n;     //隐式类型转换
pd=p1;   //编译时错误
```

更复杂的类型也是如此。假设有下面的声明

```c
int * pt;
int (*pa) [3];
int ar1[2][3];
int ar2[3][2];
int **p2; //一个指向指针的指针
```

有如下语句：

```c
pt=&ar1[0][0];//都指向int的指针
pt=ar1[0];    //都是指向int的指针
pt=ar1;       //无效，
pa=ar1;       //都是指向内含3个int类型元素数组的指针
pa=ar2;       //无效
p2=&pt;       //both pointer-to-int *
*p2=ar2[0];   //都是指向int的指针
p2=ar2；      //无效
```

注意，以上无效的赋值表达式语句涉及的两个指针都是指向不同的类型。例如，pt指向一个int类型值，而ar1指向一个内含3个int类型元素的数组。类似地，pa指向一个内含3个int类型元素的数组，所以它与ar1的类型兼容，但是ar2指向一个内含2个int类型元素的数组，所以pa与ar2不兼容。

上面的最后两个例子有些棘手。p2是指向指针的指针，它指向的指针指向int，而ar2是指向数组的指针，该数组内含2个int类型的元素，所以，p2和ar2的类型不同，不能把ar2赋给p2。但是，*p2是指向int的指针，与ar2[0]兼容。因为ar2[0]是指向该数组首元素（`ar2[0][0]`）的指针，所以ar2[0]也是指向int的指针。

若是对上面的分析还有疑惑，很可能是对`ar2`、`ar2[0]`、`ar2[0][0]`的含义还不清楚，可以去查看指针和多维数组的相关知识。