# 博客讨论

## [C语言的const类型限定符](http://blog.csdn.net/libing403/article/details/72944406)

问题：

博主能说明一下第一个例子为什么不合法，第二个例子为什么合法吗？困惑了好久，还请博主能指点迷津。
例子1

```c
char **p1;
const char **p2=p1;//不合法 [Warning] initialization from
incompatible pointer type [enabled by default]
```

例子2

```c
char *p1;
const char *p2=p1;//合法
```

我答：

首先，你第一个例子编译出现警告，但程序还是编译通过了，程序可以运行。

其次，出现警告，其原因我分析如下：

首先理解下面这段话的关键点：

指针之间的赋值比数值之间的赋值要严格。把const指针赋值给非const指针是不安全的，因为这样可以使新的指针改变const指针指向的数据。编译器在编译代码时，可能会给出警告，这样的代码是未定义的。但是把非const指针赋值给const指针没问题，**前提是只进行一次解引用。但是进行两级解引用时，这样的赋值也是不安全的。**

你给出的例子2，把非const指针赋值给const指针并且只进行一次解引用，这样没问题，因此是合法的。但是你的例子1，进行两次解引用，因此是不合法的，编译器会给出警告，即指针的兼容性问题。

那么如何理解例子1存在不安全问题呢？看下面的例子：

```c
const int **pp2;
int *p1;
const int n=13;
pp2=&p1; /*允许,但是这导致const限定符失效（根据第一行代码，不能通过*pp2修改它指向的内容）*/
*pp2= &n; /*有效，两者都声明为const，但是这导致p1指向n（*pp2已被修改）*/
*p1=10;   /*有效，但是这将改变n的值（但是根据第3行代码，要求不能改变n的值）*/
```

为什么会这样？C标准规定了通过非const指针更改const数据是未定义的。不同的编译器编译的程序其运行结果可能是不一样的。我在windows下使用gcc编译，程序运行后n的最终值是10。

当然，可以忽略这些警告，但是程序运行的结果是不可信的。

这样，你两个例子的疑惑就算解决了。

参考资料：

史蒂芬・普拉达. C Primer Plus (第6版) 中文版[M]. 人民邮电出版社, 2016.

